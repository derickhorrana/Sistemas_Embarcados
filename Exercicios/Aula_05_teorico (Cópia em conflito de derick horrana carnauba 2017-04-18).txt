1. Considerando a biblioteca-padrão da linguagem C, responda:

	(a) Quais são as funções (e seus protótipos) para abrir e fechar arquivos?

- fopen()
Esta é a função de abertura de arquivos. Seu
protótipo é:
FILE *fopen (char *nome_do_arquivo,char *modo);
O nome_do_arquivo determina qual arquivo deverá ser aberto. Este nome deve ser
válido no sistema operacional que estiver sendo utilizado. O modo de abertura diz à
função fopen() que tipo de uso você vai fazer do arquivo. 
"r"
Abre um arquivo texto para leitura. O arquivo deve existir antes de ser
aberto.
"w"
Abrir um arquivo texto para gravação. Se o arquivo não existir, ele será
criado. Se já existir, o conteúdo anterior será destruído.
"a"
Abrir um arquivo texto para gravação. Os dados serão adicionados no fim
do arquivo ("append"), se ele já existir, ou um novo arquivo será criado,
no caso de arquivo não existente anteriormente.
"rb" Abre um arquivo binário para leitura. Igual ao modo "r" anterior, só que o
arquivo é binário.
"wb"
Cria um arquivo binário para escrita, como no modo "w" anterior, só que o
arquivo é binário.
"ab"
Acrescenta dados binários no fim do arquivo, como no modo "a" anterior,
só que o arquivo é binário.
"r+"
Abre um arquivo texto para leitura e gravação. O arquivo deve existir e
pode ser modificado.
"w+"
Cria um arquivo texto para leitura e gravação. Se o arquivo existir, o
conteúdo anterior será destruído. Se não existir, será criado.
"a+"
Abre um arquivo texto para gravação e leitura. Os dados serão
adicionados no fim do arquivo se ele já existir, ou um novo arquivo será
criado, no caso de arquivo não existente anteriormente.
"r+b"
Abre um arquivo binário para leitura e escrita. O mesmo que "r+" acima,
só que o arquivo é binário.
"w+b"
Cria um arquivo binário para leitura e escrita. O mesmo que "w+" acima,
só que o arquivo é binário.
"a+b"
Acrescenta dados ou cria uma arquivo binário para leitura e escrita. O
mesmo que "a+" acima, só que o arquivo é binário.

exit()
A função exit() possui um protótipo do tipo:
void exit (int codigo_de_retorno);
Para utilizá-la deve-se colocar um include para o arquivo de cabeçalho stdlib.h. Esta
função aborta a execução do programa. Pode ser chamada de qualquer ponto no
programa e faz com que o programa termine e retorne, para o sistema operacional, o
código_de_retorno. A convenção mais usada é que um programa retorne zero no caso
de um término normal e retorne um número não nulo no caso de ter ocorrido um
problema. A função exit() se torna importante em casos como alocação dinâmica e
abertura de arquivos pois nestes casos, se o programa não conseguir a memória
necessária ou abrir o arquivo, a melhor saída pode ser terminar a execução do
programa. Pode-se reescrever o exemplo da seção anterior usando agora o exit() para
garantir que o programa não deixará de abrir o arquivo:
#include <stdio.h>
#include <stdlib.h> /* Para a função exit() */
main (void)
{
FILE *fp;
...
fp=fopen ("exemplo.bin","wb");
if (!fp)
{
printf ("Erro na abertura do arquivo. Fim de programa.");
exit (1);
}
...
return 0;
}


fclose()
Quando termina-se de usar um arquivo que aberto, deve-se fechá-lo. Para tanto usa-se
a função fclose():
int fclose (FILE *fp);
O ponteiro fp passado à função fclose() determina o arquivo a ser fechado. A função
retorna zero no caso de sucesso.
Fechar um arquivo faz com que qualquer caracter que tenha permanecido no "buffer"
associado ao fluxo de saída seja gravado. Mas, o que é este "buffer"? Quando você
envia caracteres para serem gravados em um arquivo, estes caracteres são
armazenados temporariamente em uma área de memória (o "buffer") em vez de serem
escritos em disco imediatamente. Quando o "buffer" estiver cheio, seu conteúdo é
escrito no disco de uma vez. A razão para se fazer isto tem a ver com a eficiência nas
leituras e gravações de arquivos. Se, para cada caracter que se fosse gravar, tivesse
que posicionar a cabeça de gravação em um ponto específico do disco, apenas para
gravar aquele caracter, as gravações seriam muito lentas. Assim estas gravações só
serão efetuadas quando houver um volume razoável de informações a serem gravadas
ou quando o arquivo for fechado.
A função exit() fecha todos os arquivos que um programa tiver aberto.


	(b) Quais são as funções (e seus protótipos) para escrever em arquivos?

putc()
A função putc é a primeira função de escrita de arquivo que veremos. Seu protótipo é:
int putc (int ch,FILE *fp);
Escreve um caractere no arquivo.

O programa a seguir lê uma string do teclado e escreve-a, caractere por caractere em
um arquivo em disco (o arquivo arquivo.txt, que será aberto no diretório corrente).
#include <stdio.h>
#include <stdlib.h>
int main()
{
FILE *fp;
char string[100];
int i;
fp = fopen("arquivo.txt","w"); /* Arquivo ASCII, para escrita */
if(!fp)
{
printf( "Erro na abertura do arquivo");
exit(0);
}
printf("Entre com a string a ser gravada no arquivo:");
gets(string);
for(i=0; string[i]; i++) putc(string[i], fp); /* Grava a string, caractere a
caractere */
fclose(fp);
return 0;
}
Depois de executar este programa, verifique o conteúdo do arquivo arquivo.txt (você
pode usar qualquer editor de textos ou visualizador). Você verá que a string que você
digitou está armazenada nele.getc
Retorna um caractere lido do arquivo. Protótipo:
int getc (FILE *fp);

fwrite()
A função fwrite() funciona como a sua companheira fread(), porém escrevendo no
arquivo. Seu protótipo é:
unsigned fwrite(void *buffer,int numero_de_bytes,int count,FILE *fp);
A função retorna o número de itens escritos. Este valor será igual a count a menos que
ocorra algum erro.
O exemplo abaixo ilustra o uso de fwrite e fread para gravar e posteriormente ler uma
variável float em um arquivo binário.
#include <stdio.h>
#include <stdlib.h>
int main()
{
FILE *pf;
float pi = 3.1415;
float pilido;
if((pf = fopen("arquivo.bin", "wb")) == NULL) /* Abre arquivo binário para
escrita */
{
printf("Erro na abertura do arquivo");
exit(1);
}
if(fwrite(&pi, sizeof(float), 1,pf) != 1) /* Escreve a variável pi */
printf("Erro na escrita do arquivo");
fclose(pf); /* Fecha o arquivo */
if((pf = fopen("arquivo.bin", "rb")) == NULL) /* Abre o arquivo novamente
para leitura */
{
printf("Erro na abertura do arquivo");
exit(1);
}
if(fread(&pilido, sizeof(float), 1,pf) != 1) /* Le em pilido o valor da
variável armazenada anteriormente */
printf("Erro na leitura do arquivo");
printf("\nO valor de PI, lido do arquivo e': %f", pilido);
fclose(pf);
return(0);
}
Note-se o uso do operador sizeof, que retorna o tamanho em bytes da variável ou do
tipo de dados.

	(c) Quais são as funções (e seus protótipos) para ler arquivos?
fgets()
Para se ler uma string num arquivo pode-se usar fgets() cujo protótipo é:
char *fgets (char *str, int tamanho,FILE *fp);
A função recebe três argumentos: a string a ser lida, o limite máximo de caracteres a
serem lidos e o ponteiro para FILE, que está associado ao arquivo de onde a string
será lida. A função lê a string até que um caracter de nova linha seja lido ou tamanho-
1 caracteres tenham sido lidos. Se o caracter de nova linha ('\n') for lido, ele fará parte
da string, o que não acontecia com gets. A string resultante sempre terminará com '\0'
(por isto somente tamanho-1 caracteres, no máximo, serão lidos).
A função fgets é semelhante à função gets(), porém, além dela poder fazer a leitura
a partir de um arquivo de dados e incluir o caracter de nova linha na string, ela ainda
especifica o tamanho máximo da string de entrada. Como vimos, a função gets não
tinha este controle, o que poderia acarretar erros de "estouro de buffer". Portanto,
levando em conta que o ponteiro fp pode ser substituído por stdin, como visto
anteriormente, uma alternativa ao uso de gets é usar a seguinte construção:
fgets (str, tamanho, stdin);
onde str é a string que se está lendo e tamanho deve ser igual ao tamanho alocado
para a string subtraído de 1, por causa do '\0'.

fread()
Com esta função pode-se escrever e ler blocos de dados. Para tanto, existem as
funções fread() e fwrite(). O protótipo de fread() é:
unsigned fread (void *buffer, int numero_de_bytes, int count, FILE
*fp);
O buffer é a região de memória na qual serão armazenados os dados lidos. O
argumento numero_de_bytes contém o tamanho da unidade a ser lida. count indica
quantas unidades devem ser lidas. Isto significa que o número total de bytes lidos é:
numero_de_bytes*count
A função retorna o número de unidades efetivamente lidas. Este número pode ser
menor que count quando o fim do arquivo for encontrado ou ocorrer algum erro.
Quando o arquivo for aberto para dados binários, fread pode ler qualquer tipo de
dados.

	(d) Quais são as funções (e seus protótipos) para reposicionar um ponteiro para arquivo?

	(e) Quais bibliotecas devem ser incluídas no código para poder utilizar as funções acima?

<stdio.h> Tratamento de entrada/saída.
<stdlib.h>Implementa funções para diversas operações, incluindo conversão,  alocação de memória, controle de processo, funções de busca e ordenação

2. O que é a norma POSIX?

É uma família de normas definidas pelo IEEE designadas por
IEEE1003;
O objetivo é garantir a portabilidade do código fonte de um
programa entre sistemas operativos distintos que obdeçam
às regras da norma POSIX;
Estas regras atuam como interface entre sistemas
operativos distintos;
A Norma POSIX especifica os interfaces do utilizador e do
software ao sistema operativo;

3. Considerando a norma POSIX, responda:
	(a) Quais são as funções (e seus protótipos) para abrir e fechar arquivos?

open: abrir e opcionalmente criar um arquivo pra leitura/escrita.
protótipo: int open(const char* path, int oflag,... )

	(b) Quais são as funções (e seus protótipos) para escrever em arquivos?

Posix write 
protótipo; ssize_t write (int fildes, const void * buf , size_t nbyte );

	(c) Quais são as funções (e seus protótipos) para ler arquivos?

Posix read
protótipo: size_t read (int fildes, void *buf, size_t nbyte);

	(d) Quais são as funções (e seus protótipos) para reposicionar um ponteiro para arquivo?

Posix Lseek: reposiciona o ponteiro do descritor do arquivo em um arquivo aberto
off_t lseek (int fd, off_t, int whence );

	(e) Quais bibliotecas devem ser incluídas no código para poder utilizar as funções acima?

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>